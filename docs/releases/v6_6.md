---
title: ServiceStack v6.6
---

<script setup>
import { Icon } from "@iconify/vue"
import VueTailwindTemplates from "../src/components/VueTailwindTemplates.vue"
import VueComponentGallery from "../src/components/VueComponentGallery.vue"

import Hello from  "../src/components/v6_6/Hello.vue"
import Counter from  "../src/components/v6_6/Counter.vue"
import Plugin from  "../src/components/v6_6/Plugin.vue"
import HelloApi from  "../src/components/v6_6/HelloApi.vue"

import metadata from "../src/gallery/metadata.json"
import { useMetadata } from '@servicestack/vue'
const { setMetadata } = useMetadata()
setMetadata(metadata)
</script>

<link rel="stylesheet" href="/css/not-prose.css">
<link rel="stylesheet" href="/css/release.css">

<div>
    <Icon icon="vscode-icons:file-type-js-official" class="w-80 h-80 block mx-auto" />
</div>

We're got a feature-packed JavaScript focus release that takes advantage of [JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) support in modern browsers to enable a simplified rapid development experience without the disadvantages that have plagued 
Single Page Apps (SPA) development up till now.

### JavaScript Modules

[JavaScript modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) have revolutionized the way we write and structure code in modern browsers which provide a number of advantages including better code organization and reuse, improved maintainability, and increased modularity and scalability which has seen it become a popular choice for building complex, scalable web applications. 

With modules, developers can create small, focused pieces of code that can be easily imported and used in other parts of their application without needing to rely on any complex tooling. This results in a cleaner, more organized codebase that is easier to maintain over time. 

## Modern Vue.js Tailwind .NET Apps

We've embraced JS Modules in this release with a number of new integrated features to maximize productivity and performance for this revolutionary new approach to Web App development that offers new dramatically simplified and friction-free development experience without the need to rely on any heavy npm build tools - which we believe offers the best mix of productivity and simplicity available today.

Spearheaded by our exciting new [@servicestack/vue](https://vue-mjs.web-templates.io/vue/) Vue.js Tailwind Components, we've created a number of new Vue.js Tailwind project templates preconfigured with a minimal set of libraries to make you immediately productive out-of-the-box.

<div id="vue-templates" class="mt-12 flex flex-col items-center">
    <div>
        <Icon icon="vscode-icons:file-type-vue" class="w-24 h-24 mr-8" />
        <Icon icon="logos:tailwindcss-icon" class="w-28 h-28" />
    </div>
</div>
<div class="relative bg-white py-4">
  <div class="mx-auto max-w-md px-4 text-center sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8">
    <p class="mt-2 text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl">Vue.js Tailwind Templates</p>
  </div>
</div>

<VueTailwindTemplates />

## Vue.js Tailwind Live Demos

All Razor Pages and MVC templates utilize the JS Modules support in modern browsers to avoid any needing any npm build system, 
for access to more advanced npm library features and to learn about Jamstack CDN and SSG benefits checkout [Jamstack Templates docs](https://vue-mjs.web-templates.io/templates-jamstack).

<div class="not-prose mt-8 grid grid-cols-2 gap-4">
    <a class="block group border hover:border-indigo-700" href="https://vue-mjs.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/vue-mjs.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">vue-mjs.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://razor-tailwind.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/razor-tailwind.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">razor-tailwind.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://mvc-tailwind.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/mvc-tailwind.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">mvc-tailwind.web-templates.io</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://vue-vite.jamstacks.net">
        <img class="p-2 max-h-[301px]" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/vue-vite.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">vue-vite.jamstacks.net</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://vue-ssg.jamstacks.net">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/vue-ssg.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">vue-ssg.jamstacks.net</div>
    </a>
    <a class="block group border hover:border-indigo-700" href="https://web-tailwind.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/web-tailwind.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">web-tailwind.web-templates.io</div>
    </a>
</div>

To help choosing which template to start with, here's a quick summary of their differences:

 - **vue-mjs** - Flagship Vue.mjs template complete with [OrmLite](/ormlite/), [AutoQuery](/autoquery), [boosted htmx](https://htmx.org/attributes/hx-boost/) links & [static pre-rendered blogs](https://vue-mjs.web-templates.io/blog/prerendering)
 - **razor-tailwind** - Simpler Razor Pages Template without a configured DB or static pre-rendered blogs
 - **mvc-tailwind** - Want to use MVC Identity Auth and Entity Framework
 - **web-tailwind** - Empty tailwind template who don't want to use Razor Pages or MVC
 - **vue-vite** - Want to use TypeScript in a simpler Vite SPA App
 - **vue-ssg** - Want to use TypeScript in an advanced JAMStack SSG template

 For a more in-depth look we've created an overview covering the differences between the Razor Pages & MVC templates:

<div class="flex justify-center">
<iframe class="video-hd" src="https://www.youtube.com/embed/Sb1hsy4S9v4" frameborder="0" allow="autoplay; encrypted-media" allowfullscreen></iframe>
</div>

### Vue.js Bootstrap Razor Pages Template

<div class="flex justify-center"><Icon icon="logos:bootstrap" class="my-8 w-24 h-24" /></div>

<div class="not-prose flex justify-center">
    <a class="block max-w-xl group border hover:border-indigo-700" href="https://razor-pages.web-templates.io">
        <img class="p-2" src="https://raw.githubusercontent.com/ServiceStack/Assets/master/csharp-templates/razor-pages.png">
        <div class="bg-gray-50 text-gray-600 font-semibold group-hover:bg-indigo-700 group-hover:text-white text-center py-2">razor-pages.web-templates.io</div>
    </a>
</div>

For devs preferring Bootstrap, we've also created a new Razor Pages template integrated with JS Modules, that can be installed with:

:::sh
x new razor-pages MyApp
:::

## JS Modules Quick Look

We'll take a quick glimpse on some of the power of JS Modules with the introduction of our new **JS Module ES6 class DTOs** feature, where you'll be able to walk up to any ServiceStack v6.6+ Web App, import some external modules independent from the rest of the page, then call end-to-end typed APIs without using any pre existing JS libraries or build tools in sight!

The Blazor Server live demo at [blazor-server.jamstacks.net](https://blazor-server.jamstacks.net) is a good one to try this on given it's built on an entirely different server rendered technology stack. To try it out press `F12` to open a dev console then paste in the sample code below:

```js
document.body.insertAdjacentHTML('beforeend',`<div style="position:fixed;right:1em;top:5em">
    <input type="text" id="txtName">
    <div id="result"></div>
</div>`)

const ServiceStack = await import('https://unpkg.com/@servicestack/client@2/dist/servicestack-client.mjs')
const dtos = await import('/types/mjs')
const { JsonApiClient, on, $1 } = ServiceStack
const client = JsonApiClient.create()

on('#txtName', {
    async keyup(el) {
        const api = await client.api(new dtos.Hello({ name:el.target.value }))
        $1('#result').innerHTML = api.response.result
    }
})
```

After the browser asynchronously loads the modules you should see a working text input which calls its [Hello API](https://blazor-server.jamstacks.net/ui/Hello) on each key press:

<a href="https://blazor-server.jamstacks.net"><div class="my-8 mx-auto max-w-xl block flex justify-center shadow hover:shadow-lg rounded py-1"><img class="p-4" src="/images/release-notes/v6.6/js-modules-dev-console.png"></div></a>

### Dynamically Loading Multiple JS Modules

Ok that's cool, but let's see how far we can go with it and introduce the new [Vue.js Tailwind Components](/vue/) into the mix to see how close we can get to recreating some of this Blazor Server App's functionality.

Lets head over to the Bookings page and Sign In:

<a class="block text-3xl text-center py-4 font-semibold" href="https://blazor-server.jamstacks.net/secure/bookings" target="_blank">blazor-server.jamstacks.net/secure/bookings</a>

Then press `F12` to open the dev console again to paste and run the code below:

```js
const im = document.createElement('script');
im.type = 'importmap';
im.textContent = JSON.stringify({
    "imports": {
        "vue": "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js",
        "@servicestack/client": "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs",
        "@servicestack/vue": "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs"
    }
});
document.body.appendChild(im)

const Vue = await import('vue')
const ServiceStack = await import('@servicestack/client')
const ServiceStackVue = await import('@servicestack/vue')
const dtos = await import('/types/mjs')

const BookingsApp = {
  template:`
  <div class="sm:max-w-fit p-4 m-4">
    <h3 class="ml-4 text-center text-2xl font-medium">Vue.js Bookings</h3>
    <AutoCreateForm v-if="create" type="CreateBooking" @done="done" @save="done" />
    <AutoEditForm v-else-if="edit" type="UpdateBooking" deleteType="DeleteBooking" v-model="edit" 
      @done="done" @save="done" @delete="done" />
    <OutlineButton @click="reset({ create:true })">New Booking</OutlineButton>
    <DataGrid :items="bookings" type="Booking" 
      selected-columns="id,name,roomType,roomNumber,cost,bookingStartDate,bookingEndDate,couponId" 
      :header-titles="{roomNumber:'Room No',bookingStartDate:'Start Date',bookingEndDate:'End Date',couponId:'Voucher'}"
      :visible-from="{ name:'xl', bookingStartDate:'sm', bookingEndDate:'xl', couponId:'xl' }"
      @row-selected="editId = editId == $event.id ? null : $event.id" :is-selected="row => editId == row.id" />
  </div>`,
  setup(props) {
    const { ref, onMounted, watch } = Vue
    const { useClient, useAuth, useFormatters } = ServiceStackVue
    const { QueryBookings } = dtos

    const create = ref(false)
    const editId = ref()
    const edit = ref()
    const bookings = ref([])

    const client = useClient()
    const { currency } = useFormatters()
    
    async function refresh() {
      const api = await client.api(new QueryBookings())
      if (api.succeeded) {
        bookings.value = api.response.results || []
      }
    }
    onMounted(refresh)

    function reset(args={}) {
      create.value = args.create ?? false
      editId.value = args.editId ?? undefined
    }

    function done() {
      refresh()
      reset()
    }
    
    watch(editId, async () => {
      if (editId.value) {
        const api = await client.api(new QueryBookings({ id: editId.value }))
        if (api.succeeded) {
          edit.value = api.response.results[0]
          return
        }
      }
      edit.value = null
    })
    
    return { create, editId, edit, bookings, reset, done, currency }
  }
}

const app = Vue.createApp(BookingsApp, { value:'JS Modules' })
app.provide('client', ServiceStack.JsonApiClient.create())
app.use(ServiceStackVue.default)
await ServiceStackVue.useMetadata().loadMetadata()

document.querySelector('main').insertAdjacentHTML('beforeend',`<div id="app"></div>`)
app.mount('#app')
```

Give it a moment to load all the modules and you should see a shiny new freshly baked Vue.js data grid infiltrating the Blazor Server App!

<div class="mb-16"><a href="https://blazor-server.jamstacks.net/secure/bookings" target="_blank"><img class="w-[1330px] -ml-40" style="max-width:none" src="/images/release-notes/v6.6/js-modules-bookings-crud.png"></a></div>

This isn't just cosmetic, it's a full CRUD Bookings App with responsive formatted [DataGrid](/vue/gallery/datagrid) columns, 
API-enabled [AutoForm](/vue/gallery/autoform) components powered by the App's [API Metadata](/vue/use-metadata) 
with populated Enum drop downs, optimal number, date & checkbox inputs and validation binding:


<div class="mt-16"><a href="https://blazor-server.jamstacks.net/secure/bookings" target="_blank"><img class="my-8 w-[1330px] -ml-40" style="max-width:none" src="/images/release-notes/v6.6/js-modules-bookings-crud-update.png"></a></div>

It doesn't have all the features of the [Blazor AutoQueryGrid](https://blazor-gallery.servicestack.net/gallery/autoquerygrid) component yet, 
but with a few lines of code to load a few modules and create a custom Vue 3 reactive component, we can get most of the functionality
without any of the heavy build tools complexity of a Blazor App or traditional npm SPA App and their matrix of dependencies.

### Best mix of Productivity vs Simplicity

From a pragmatic standpoint we believe JS Modules offers the best mix of productivity and simplicity, that can be progressively added
to enhance server rendered Razor Pages with interactive reactive components without imposing its technical choices and bloating its 
other pages which are free to choose whichever libraries are best to implement its features.

### Various WebApp DTO Options

The only requirement for this to work is that the libraries are written as [JS Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules) which is a popular build target, but given we want to enable a typed and build-tools free future we've added a new **.mjs** [Add ServiceStack Reference](https://vue-mjs.web-templates.io/add-servicestack-reference) endpoint at **/types/mjs** to return your APIs DTOs in annotated ES6 class JS Module. To see where they benefit, lets quickly go over the existing options:

### Common.js ES3 DTOs

Our existing [JavaScript Add ServiceStack Reference](https://vue-mjs.web-templates.io/javascript-add-servicestack-reference) support returns your API DTOs in **ES3** Common JS format, i.e. the default Target of TypeScript, in order to generate JS that's also compatible with older, out-dated browsers from 1999, that looks like:

```js
var Hello = /** @class */ (function () {
    function Hello(init) {
        Object.assign(this, init);
    }
    Hello.prototype.getTypeName = function () { return 'Hello'; };
    Hello.prototype.getMethod = function () { return 'POST'; };
    Hello.prototype.createResponse = function () { return new HelloResponse(); };
    return Hello;
}());
exports.Hello = Hello;

var HelloResponse = /** @class */ (function () {
    function HelloResponse(init) {
        Object.assign(this, init);
    }
    return HelloResponse;
}());
exports.HelloResponse = HelloResponse;
```

This does enable a similar build-free dev experience which lets you easily include your APIs DTOs in a page along with an 
[Embedded UMD @servicestack/client](https://vue-mjs.web-templates.io/servicestack-client-umd) to start making API calls, e.g:

```html
<script src="/js/require.js"></script>
<script src="/js/servicestack-client.js"></script>
<script src="/types/js"></script>
<script>
var { JsonServiceClient, Hello } = exports

var client = new JsonServiceClient()
function callHello(name) {
    client.get(new Hello({ name }))
        .then(function(r) {
            document.getElementById('result').innerHTML = r.result
        });
}
</script>
```

But it offers no type-checking or intelli-sense assistance during development, luckily we can [enable static analysis](https://vue-mjs.web-templates.io/servicestack-client-umd#rich-intelli-sense-support) support by including [TypeScript dtos.ts](https://vue-mjs.web-templates.io/typescript-add-servicestack-reference) in the same project which smart IDEs like [JetBrains Rider](https://www.jetbrains.com/rider/) will find to light up assistance.

### TypeScript DTOs

The TypeScript DTOs capture the most Type Information about your in API DTOs in generic TypeScript classes:

```ts
// @Route("/hello")
// @Route("/hello/{Name}")
export class Hello implements IReturn<HelloResponse>
{
    public name?: string;

    public constructor(init?: Partial<Hello>) { (Object as any).assign(this, init); }
    public getTypeName() { return 'Hello'; }
    public getMethod() { return 'POST'; }
    public createResponse() { return new HelloResponse(); }
}

export class HelloResponse
{
    public result: string;

    public constructor(init?: Partial<HelloResponse>) { (Object as any).assign(this, init); }
}
```

Which is still the best option to use in our [JAMStack TypeScript templates](https://vue-mjs.web-templates.io/templates-jamstack) where the DTOs integrate with the rest of your App's TypeScript code-base, where its npm build tools transforms it into its configured downlevel JS target bundles.

The primary issue being that Browsers can't run them natively, so developing in TypeScript typically requires an npm build system to do the transformation which adds complexity and results in slower iterative dev cycles.

### JS Module ES6 class DTOs

The new ES6 classes combines the best of both worlds to enable a productive type-safe development model during development but can also be referenced as-is in JS Module scripts and run natively in browsers without any build tools!

To achieve this the ES6 classes are annotated with [JSDoc](https://jsdoc.app) type hints in comments which enjoys broad support in IDEs and
tools like TypeScript where it can be used to [provide type information in JavaScript files](https://www.typescriptlang.org/docs/handbook/jsdoc-supported-types.html), which looks like:

```js
export class Hello {
    /** @param {{name?:string}} [init] */
    constructor(init) { Object.assign(this, init) }
    /** @type {string} */
    name;
    getTypeName() { return 'Hello' }
    getMethod() { return 'GET' }
    createResponse() { return new HelloResponse() }
}

export class HelloResponse {
    /** @param {{result?:string,responseStatus?:ResponseStatus}} [init] */
    constructor(init) { Object.assign(this, init) }
    /** @type {string} */
    result;
    /** @type {?ResponseStatus} */
    responseStatus;
}
```

Which our JS Apps can immediately use by referencing the **/types/mjs** endpoint directly:

```js
import { Hello } from '/types/mjs'
const api = await client.api(new Hello({ name }))
```

That for better IDE intelli-sense during development, we can save to disk with:

:::sh
npm run dtos
:::

Where it enables IDE static analysis when calling Typed APIs from JavaScript:

```js
import { Hello } from '/mjs/dtos.mjs'
```

![](/images/release-notes/v6.6/mjs-intellisense.png)

### .mjs Add ServiceStack Reference

The new JS Modules DTOs is now a first-class [Add ServiceStack Reference language](https://servicestack.net/service-reference) supported language complete with IDE integration in the latest VS .NET and JetBrains IDEs extensions:

<div class="not-prose mt-8 grid grid-cols-2 gap-4 ">
    <a class="block bg-neutral-900 group border border-neutral-800 hover:border-indigo-700" href="https://marketplace.visualstudio.com/items?itemName=Mythz.ServiceStackVS">
        <div class="bg-neutral-700 text-white font-semibold group-hover:bg-indigo-700 text-center py-2">VS.NET</div>
        <img class="" src="/images/servicestack-reference/mjs-update-reference-vs.png">
    </a>
    <a class="block bg-neutral-900 group border border-neutral-800 hover:border-indigo-700" href="https://plugins.jetbrains.com/plugin/17295-servicestack">
        <div class="bg-neutral-700 text-white font-semibold group-hover:bg-indigo-700 text-center py-2">JetBrains Rider</div>
        <img class="" src="/images/servicestack-reference/mjs-update-reference-rider.png">
    </a>
</div>

Including support in the latest [dotnet tool](/dotnet-tool) for creating new .mjs Add ServiceStack References:

```bash
$ x mjs https://localhost:5001
```

And updating them:

:::sh
x mjs
:::

But the best thing about JS Module DTOs is using them in the exciting new node_modules free world enabled in the new Vue.js templates!

<h2 class="hide-h2 border-none"></h2>

## Multi Page Apps

<div><div id="multi-page-apps" class="relative bg-white py-4"><div class="mx-auto max-w-md px-4 text-center sm:max-w-3xl sm:px-6 lg:max-w-7xl lg:px-8"><p class="mt-2 text-3xl font-extrabold tracking-tight text-gray-900 sm:text-4xl">Back to Multi Page Apps</p><p class="mx-auto mt-5 max-w-prose text-xl text-gray-500"> Discover the productive build tools free world of modern JS Module MPAs</p></div></div>
<div class="flex justify-around">
    <Icon icon="clarity:rack-server-line" class="w-40 h-40 text-slate-500" />
    <Icon icon="mdi:horizontal-line" class="w-40 h-40 text-slate-500" />
    <Icon icon="mdi:cloud-print-outline" class="w-40 h-40 text-slate-500" />
    <Icon icon="mdi:horizontal-line" class="w-40 h-40 text-slate-500" />
    <Icon icon="ps:browser" class="mt-4 w-36 h-36 text-slate-500" />
</div></div>

<svg class="sm:float-left mr-4 w-24 h-24" style="margin-top:0" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 630 630"><rect width="630" height="630" fill="#f7df1e"/><path d="m423.2 492.19c12.69 20.72 29.2 35.95 58.4 35.95 24.53 0 40.2-12.26 40.2-29.2 0-20.3-16.1-27.49-43.1-39.3l-14.8-6.35c-42.72-18.2-71.1-41-71.1-89.2 0-44.4 33.83-78.2 86.7-78.2 37.64 0 64.7 13.1 84.2 47.4l-46.1 29.6c-10.15-18.2-21.1-25.37-38.1-25.37-17.34 0-28.33 11-28.33 25.37 0 17.76 11 24.95 36.4 35.95l14.8 6.34c50.3 21.57 78.7 43.56 78.7 93 0 53.3-41.87 82.5-98.1 82.5-54.98 0-90.5-26.2-107.88-60.54zm-209.13 5.13c9.3 16.5 17.76 30.45 38.1 30.45 19.45 0 31.72-7.61 31.72-37.2v-201.3h59.2v202.1c0 61.3-35.94 89.2-88.4 89.2-47.4 0-74.85-24.53-88.81-54.075z"/></svg>

JavaScript has progressed significantly in recent times where many of the tooling & language enhancements
that we used to rely on external tools for is now available in modern browsers alleviating the need for
complex tooling and npm dependencies that have historically plagued modern web development.

The good news is that the complex npm tooling that was previously considered mandatory in modern JavaScript App 
development can be considered optional as we can now utilize modern browser features like 
[async/await](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function),
[JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), 
[dynamic imports](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/import), 
[import maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap)
and [modern language features](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide) for a 
sophisticated development workflow without the need for any npm build tools. 

### Bringing Simplicity Back

The new Razor Vue.mjs templates focuses on simplicity and eschews many aspects that has complicated modern JavaScript development, specifically:

 - No npm **node_modules** or build tools
 - No client side routing
 - No heavy client state

Effectively abandoning the traditional SPA approach in lieu of a simpler [MPA](https://docs.astro.build/en/concepts/mpa-vs-spa/) 
development model using Razor Pages for Server Rendered content with any interactive UIs progressively enhanced with JavaScript.

#### Freedom to use any JS library

Avoiding the SPA route ends up affording more flexibility on which JS libraries each page can use as without heavy bundled JS
blobs of all JS used in the entire App, it's free to only load the required JS each page needs to best implement its 
required functionality, which can be any JS library, preferably utilizing ESM builds that can be referenced from a 
[JavaScript Module](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules), taking advantage of the module system
native to modern browsers able to efficiently download the declarative matrix of dependencies each script needs. 

### Best libraries for progressive Multi Page Apps

By default the Razor Vue.js templates includes a collection of libraries we believe offers the best modern development experience in Progressive
MPA Web Apps, specifically:

<div><Icon icon="logos:tailwindcss-icon" class="mx-auto block w-20 h-20" /></div>

### Tailwind
[Tailwind CLI](https://tailwindcss.com/docs/installation) enables a responsive, utility-first CSS framework for creating maintainable CSS at scale without the need for any CSS
preprocessors like Sass, which is configured to run from an npx script to avoid needing any node_module dependencies.

<div><Icon icon="vscode-icons:file-type-vue" class="mx-auto block mt-8 w-20 h-20" /></div>

### Vue 3
[Vue](https://vuejs.org/guide/introduction.html) is a popular Progressive JavaScript Framework that makes it easy to create interactive Reactive Components whose
[Composition API](https://vuejs.org/api/composition-api-setup.html) offers a nice development model without requiring any pre-processors like JSX.

Where creating a component is as simple as:

```js
const Hello = {
    template: `<b>Hello, {{name}}!</b>`,
    props: { name:String }
}
```
<div class="text-center"><Hello name="Vue 3" class="text-2xl py-4" /></div>

Or a simple reactive example:

```js
import { ref } from "vue"

const Counter = {
    template: `<b @click="count++">Counter {{count}}</b>`,
    setup() {
        let count = ref(1)
        return { count }
    }
}
```

<div class="text-center"><Counter class="text-2xl py-4 select-none cursor-pointer" /></div>

These components can be mounted using the standard [Vue 3 mount](https://vuejs.org/api/application.html#app-mount) API, but to 
make it easier we've added additional APIs for declaratively mounting components to pages using the `data-component` and `data-props`
attributes, especially useful for embedding Vue components in Markdown content, e.g:  

```html
<div data-component="Hello" data-props="{ name: 'Vue 3' }"></div>
```

Alternatively they can be programmatically added using the custom `mount` method in `api.mjs`:

```js
import { mount } from "/mjs/api.mjs"
mount('#counter', Counter)
```

Both methods create components with access to all your Shared Components and any 3rd Party Plugins which
we can preview in this example that uses **@servicestack/vue's** [ModalDialog](/vue/gallery/modals) component:

```js
const Plugin = {
    template:`<div>
        <PrimaryButton @click="show=true">Open Modal</PrimaryButton>
        <ModalDialog v-if="show" @done="show=false">
            <div class="p-8">Hello @servicestack/vue!</div>
        </ModalDialog>
    </div>`,
    setup() {
        const show = ref(false)
        return { show }
    }
}
```

<div class="text-center not-prose"><Plugin class="text-center text-2xl py-4" /></div>

### @servicestack/vue

[@servicestack/vue](https://github.com/ServiceStack/servicestack-vue) is our growing Vue 3 Tailwind component library with a number of rich Tailwind components useful in .NET Web Apps, including DataGrids, Auto Forms and Input Components with integrated contextual validation binding. 

<VueComponentGallery />

<p>It's our cornerstone library for enabling a highly productive Vue.js development model across our <a href="/templates-vue">Vue Tailwind Project templates</a> which we'll be continuing to invest in future to unlock even greater productivity benefits in all Vue.js Tailwind Apps.</p>

### @servicestack/client

[@servicestack/client](https://github.com/ServiceStack/servicestack-client) is our generic JS/TypeScript client library
which enables a terse, typed API for using your App's typed DTOs from its `/types/mjs` endpoint to enable an effortless end-to-end 
Typed development model for calling your APIs **without any build steps**, e.g:

```html
<input type="text" id="txtName">
<div id="result"></div>

<script type="module">
import { JsonApiClient, $1, on } from '@servicestack/client'
import { Hello } from '/types/mjs'

on('#txtName', {
    async keyup(el) {
        const client = JsonApiClient.create()
        const api = await client.api(new Hello({ name:el.target.value }))
        $1('#result').innerHTML = api.response.result
    }
})
</script>
```

For better IDE intelli-sense during development, save the annotated Typed DTOs to disk with:

```bash
$ npm run dtos
```

That can be referenced instead to unlock your IDE's static analysis type-checking and intelli-sense benefits during development:

```js
import { Hello } from '/js/dtos.mjs'
client.api(new Hello({ name }))
```

You'll typically use all these libraries in your **API-enabled** components as seen in the 
[HelloApi.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/mjs/components/HelloApi.mjs)
component on the [home page](https://vue-mjs.web-templates.io) which calls its [Hello API](https://vue-mjs.web-templates.io/ui/Hello) on each key press:

```js
import { ref } from "vue"
import { useClient } from "@servicestack/vue"
import { Hello } from "../dtos.mjs"

export default {
    template:/*html*/`<div class="flex flex-wrap justify-center">
        <TextInput v-model="name" @keyup="update" />
        <div class="ml-3 mt-2 text-lg">{{ result }}</div>
    </div>`,
    props:['value'],
    setup(props) {
        let name = ref(props.value)
        let result = ref('')
        let client = useClient()

        async function update() {
            let api = await client.api(new Hello({ name }))
            if (api.succeeded) {
                result.value = api.response.result
            }
        }
        update()

        return { name, update, result }
    }
}
```

Which we can also mount below:

<div class="not-prose w-full font-semibold"><HelloApi value="Vue 3" class="" /></div>

We'll also go through and explain other features used in this component:

#### `/*html*/`

Although [not needed in Rider](https://vue-mjs.web-templates.io/blog/rider) (which can automatically infer HTML in strings), the `/*html*/` type hint is used to instruct tooling like the [es6-string-html](https://marketplace.visualstudio.com/items?itemName=Tobermory.es6-string-html)
VS Code extension to provide syntax highlighting and an enhanced authoring experience for HTML content in strings. 

### useClient

[useClient()](/vue/use-client) provides managed APIs around the `JsonServiceClient` instance, registered in Vue App's with:

```js
let client = JsonApiClient.create()
app.provide('client', client)
```

Which maintains contextual information around your API calls like **loading** and **error** states, used by `@servicestack/vue` components to 
enable its auto validation binding. Other functionality includes:

```js
let { 
    api,            // Send a typed API request and return results in an ApiResult<TResponse>
    apiVoid,        // Send a typed API request and return empty response in a void ApiResult
    apiForm,        // Send a FormData API request and return results in an ApiResult<TResponse>
    apiFormVoid,    // Send a FormData API request and return empty response in a void ApiResult
    loading,        // Maintain loading state whilst API Request is in transit
    error,          // Maintain API Error response in reactive Ref<ResponseStatus>
    setError,       // Set API error state with summary or field validation error
    addFieldError,  // Add field error to API error state
    unRefs          // Returns a dto with all Refs unwrapped
} = useClient()
```

#### setError

`setError` can be used to populate client-side validation errors which the 
[SignUp.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/SignUp.mjs)
component uses to report an invalid submissions when passwords don't match:

```js
async function onSubmit() {
    if (password.value !== confirmPassword.value) {
        setError({ fieldName:'confirmPassword', message:'Passwords do not match' })
        return
    }
    //...
}
```

### Form Validation

All `@servicestack/vue` Input Components support contextual validation binding that's typically populated from API
[Error Response DTOs](/error-handling) but can also be populated from client-side validation
as done above.

#### Explicit Error Handling

This populated `ResponseStatus` DTO can either be manually passed into each component's **status** property as done in [/Todos](https://vue-mjs.web-templates.io/TodoMvc):

```html
<template id="TodoMvc-template">
    <div class="mb-3">
        <text-input :status="store.error" id="text" label="" placeholder="What needs to be done?"
                    v-model="store.newTodo" v-on:keyup.enter.stop="store.addTodo()"></text-input>
    </div>
    <!-- ... -->
</template>
```

Where if you try adding an empty Todo the `CreateTodo` API will fail and populate its `store.error` reactive property with the 
APIs Error Response DTO which the `<TextInput />` component checks to display any field validation errors adjacent to the HTML Input
with the matching `id` field:

```js
let store = {
    /** @type {Todo[]} */
    todos: [],
    newTodo:'',
    error:null,
    async addTodo() {
        this.todos.push(new Todo({ text:this.newTodo }))
        let api = await client.api(new CreateTodo({ text:this.newTodo }))
        if (api.succeeded)
            this.newTodo = ''
        else 
            this.error = api.error
    },
    //...
}
```

#### Implicit Error Handling

More often you'll want to take advantage of the implicit validation support in `useClient()` which makes its state available to child
components, alleviating the need to explicitly pass it in each component as seen in razor-tailwind's
[Contacts.mjs](https://github.com/NetCoreTemplates/razor-tailwind/blob/main/MyApp/wwwroot/Pages/Contacts.mjs) `Edit` component for its
[/Contacts](https://razor-tailwind.web-templates.io/Contacts) page which doesn't do any manual error handling:

```js
const Edit = {
    template:/*html*/`<SlideOver @done="close" title="Edit Contact">
    <form @submit.prevent="submit">
      <input type="submit" class="hidden">
      <fieldset>
        <ErrorSummary except="title,name,color,filmGenres,age,agree" class="mb-4" />
        <div class="grid grid-cols-6 gap-6">
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="title" v-model="request.title" :options="enumOptions('Title')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput id="name" v-model="request.name" required placeholder="Contact Name" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="color" v-model="request.color" :options="colorOptions" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <SelectInput id="favoriteGenre" v-model="request.favoriteGenre" :options="enumOptions('FilmGenre')" />
          </div>
          <div class="col-span-6 sm:col-span-3">
            <TextInput type="number" id="age" v-model="request.age" />
          </div>
        </div>
      </fieldset>
    </form>
    <template #footer>
      <div class="flex justify-between space-x-3">
        <div><ConfirmDelete @delete="onDelete">Delete</ConfirmDelete></div>
        <div><PrimaryButton @click="submit">Update Contact</PrimaryButton></div>
      </div>
    </template>
  </SlideOver>`,
    props:['contact'],
    emits:['done'],
    setup(props, { emit }) {
        const client = useClient()
        const request = ref(new UpdateContact(props.contact))
        const colorOptions = propertyOptions(getProperty('UpdateContact','Color'))

        async function submit() {
            const api = await client.api(request.value)
            if (api.succeeded) close()
        }

        async function onDelete () {
            const api = await client.apiVoid(new DeleteContact({ id:props.id }))
            if (api.succeeded) close()
        }

        const close = () => emit('done')

        return { request, enumOptions, colorOptions, submit, onDelete, close }
    }
}
```

Effectively making form validation binding a transparent detail where all `@servicestack/vue` 
Input Components are able to automatically apply contextual validation errors next to the fields they apply to: 

<a href="https://razor-tailwind.web-templates.io/Contacts"><div class="mx-auto max-w-screen-md block flex justify-center"><img class="p-4" src="/images/scripts/edit-contact-validation.png"></div></a>

### AutoForm Components

We can elevate our productivity even further with
[Auto Form Components](/vue/gallery/autoform) that can automatically generate an
instant API-enabled form with validation binding by just specifying the Request DTO you want to create the form of, e.g:

```html
<AutoCreateForm type="CreateBooking" formStyle="card" />
```

<div class="not-prose"><AutoCreateForm type="CreateBooking" formStyle="card" /></div>

The AutoForm components are powered by your [App Metadata](/vue/use-metadata) which allows creating 
highly customized UIs from [declarative C# attributes](/locode/declarative) whose customizations are
reused across all ServiceStack Auto UIs, including:

 - [API Explorer](/api-explorer) 
 - [Locode](/locode/)
 - [Blazor Tailwind Components](/templates-blazor-components)

### useAuth

Your Vue.js code can access Authenticated Users using [useAuth()](/vue/use-auth)
which can also be populated without the overhead of an Ajax request by embedding the response of the built-in
[Authenticate API](https://vue-mjs.web-templates.io/ui/Authenticate?tab=details) inside `_Layout.cshtml` with:

```html
<script type="module">
import { useAuth } from "@@servicestack/vue"
const { signIn } = useAuth()
signIn(@await Html.ApiAsJsonAsync(new Authenticate()))
</script>
```

Where it enables access to the below [useAuth()](/vue/use-auth) utils for inspecting the 
current authenticated user:  

```js
const { 
    signIn,           // Sign In the currently Authenticated User
    signOut,          // Sign Out currently Authenticated User
    user,             // Access Authenticated User info in a reactive Ref<AuthenticateResponse>
    isAuthenticated,  // Check if the current user is Authenticated in a reactive Ref<boolean>
    hasRole,          // Check if the Authenticated User has a specific role
    hasPermission,    // Check if the Authenticated User has a specific permission
    isAdmin           // Check if the Authenticated User has the Admin role
} = useAuth()
```

This is used in [BookingsCrud/Index.mjs](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/wwwroot/Pages/BookingsCrud/Index.mjs)
to control whether the `<AutoEditForm>` component should enable its delete functionality:

```js
export default {
    template/*html*/:`
    <AutoEditForm type="UpdateBooking" :deleteType="canDelete ? 'DeleteBooking' : null" />
    `,
    setup(props) {
        const { hasRole } = useAuth()
        const canDelete = computed(() => hasRole('Manager'))
        return { canDelete }
    }
}
```

#### [JSDoc](https://jsdoc.app)

We get great value from using [TypeScript](https://www.typescriptlang.org) to maintain our libraries typed code bases, however it 
does mandate using an external tool to convert it to valid JS before it can be run, something The Razor Vue.js templates expressly avoids. 

Instead it adds JSDoc type annotations to code where it adds value, which at the cost of slightly more verbose syntax enables much of the 
same static analysis and intelli-sense benefits of TypeScript, but without needing any tools to convert it to valid JavaScript, e.g: 

```js
/** @param {KeyboardEvent} e */
function validateSafeName(e) {
    if (e.key.match(/[\W]+/g)) {
        e.preventDefault()
        return false
    }
}
```

#### TypeScript Language Service

Whilst the code-base doesn't use TypeScript syntax in its code base directly, it still uses TypeScript's language services to enable
static analysis for the included libraries from the TypeScript definitions included in `/lib/typings`, downloaded 
in [postinstall.js](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/postinstall.js) after npm install.

### Import Maps

[Import Maps](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/script/type/importmap) is a useful browser feature that allows
specifying optimal names for modules, that can be used to map package names to the implementation it should use, e.g:

```csharp
@Html.StaticImportMap(new() {
    ["vue"]                  = "/lib/mjs/vue.mjs",
    ["@servicestack/client"] = "/lib/mjs/servicestack-client.mjs",
    ["@servicestack/vue"]    = "/lib/mjs/servicestack-vue.mjs",
})
```

Where they can be freely maintained in one place without needing to update any source code references.
This allows source code to be able to import from the package name instead of its physical location:

```js
import { ref } from "vue"
import { useClient } from "@servicestack/vue"
import { JsonApiClient, $1, on } from "@servicestack/client"
```

It's a great solution for specifying using local unminified debug builds during **Development**, and more optimal CDN hosted 
production builds when running in **Production**, alleviating the need to rely on complex build tools to perform this code transformation for us:

```csharp
@Html.ImportMap(new()
{
    ["vue"]                  = ("/lib/mjs/vue.mjs",                 "https://unpkg.com/vue@3/dist/vue.esm-browser.prod.js"),
    ["@servicestack/client"] = ("/lib/mjs/servicestack-client.mjs", "https://unpkg.com/@servicestack/client@2/dist/servicestack-client.min.mjs"),
    ["@servicestack/vue"]    = ("/lib/mjs/servicestack-vue.mjs",    "https://unpkg.com/@servicestack/vue@3/dist/servicestack-vue.min.mjs")
})
```

> Note: Specifying exact versions of each dependency improves initial load times by eliminating latency from redirects. 

Or if you don't want your Web App to reference any external dependencies, have the ImportMap reference local minified production builds instead:

```csharp
@Html.ImportMap(new()
{
    ["vue"]                  = ("/lib/mjs/vue.mjs",                 "/lib/mjs/vue.min.mjs"),
    ["@servicestack/client"] = ("/lib/mjs/servicestack-client.mjs", "/lib/mjs/servicestack-client.min.mjs"),
    ["@servicestack/vue"]    = ("/lib/mjs/servicestack-vue.mjs",    "/lib/mjs/servicestack-vue.min.mjs")
})
```

#### Polyfill for Safari

Unfortunately Safari is the last modern browser to [support import maps](https://caniuse.com/import-maps) which is only now in
Technical Preview. Luckily this feature can be polyfilled with the pre-configured [ES Module Shims](https://github.com/guybedford/es-module-shims):

```html
@if (Context.Request.Headers.UserAgent.Any(x => x.Contains("Safari") && !x.Contains("Chrome")))
{
    <script async src="https://ga.jspm.io/npm:es-module-shims@1.6.3/dist/es-module-shims.js"></script>
}
```

### Fast Component Loading

SPAs are notorious for being slow to load due to needing to download large blobs of JavaScript bundles that it needs to initialize
with their JS framework to mount their App component before it starts fetching the data from the server it needs to render its components. 

A complex solution to this problem is to server render the initial HTML content then re-render it again on the client after the page loads. 
A simpler solution is to avoid unnecessary ajax calls by embedding the JSON data the component needs in the page that loads it, which is what [/Todos](https://vue-mjs.web-templates.io/TodoMvc) does to load its initial list of todos using the [Service Gateway](/service-gateway) to invoke APIs in process and embed its JSON response with:

```html
<script>todos = @await ApiResultsAsJsonAsync(new QueryTodos())</script>
<script type="module">
import TodoMvc from "/Pages/TodoMvc.mjs"
import { mount } from "/mjs/app.mjs"
mount('#todomvc', TodoMvc, { todos })
</script>
```

Where `ApiResultsAsJsonAsync` is a simplified helper that uses the [Gateway](/service-gateway) to call your API and returns its unencoded JSON response:

```csharp
(await Gateway.ApiAsync(new QueryTodos())).Response?.Results.AsRawJson();
```

The result of which should render the List of Todos instantly when the page loads since it doesn't need to perform any additional Ajax requests
after the component is loaded.

### Fast Page Loading

We can get SPA-like page loading performance using htmx's [Boosting](https://htmx.org/docs/#boosting) feature which avoids full page reloads
by converting all anchor tags to use Ajax to load page content into the page body, improving performance from avoiding needing to reload 
scripts and CSS in `<head>`

This is used in [Header.cshtml](https://github.com/NetCoreTemplates/vue-mjs/blob/main/MyApp/Pages/Shared/Header.cshtml) to **boost** all
main navigation links:

```html
<nav hx-boost="true">
    <ul>
        <li><a href="/Blog">Blog</a></li>
    </ul>
</nav>
```

htmlx has lots of useful [real world examples](https://htmx.org/examples/) that can be activated with declarative attributes, 
another feature the **vue-mjs** template uses is the [class-tools](https://htmx.org/extensions/class-tools/) extension to hide elements from 
appearing until after the page is loaded:

```html
<div id="signin"></div>
<div class="hidden mt-5 flex justify-center" classes="remove hidden:load">
    @Html.SrcPage("SignIn.mjs")
</div>
```

Which reduces UI yank from not showing server rendered content before JS components have loaded. 

### Fast pre-rendered Razor Pages

[![](https://images.unsplash.com/photo-1522526886914-6e8d4fd91399?crop=entropy&fit=crop&h=500&w=1000)](https://vue-mjs.web-templates.io/blog/prerendering)

<Icon icon="logos:jamstack-icon" class="w-24 h-24 ml-4 float-right" />

Whilst not required, the **vue-mjs** template also includes support for pre-rendering static content from Razor Pages.

Prerendering static content is a popular technique used by JAMStack Apps to improve the performance, reliability and scalability of Web Apps that's able to save unnecessary computation at runtime by generating static content at deployment which can be optionally hosted from a CDN for even greater performance.

As such we thought it a valuable technique to include in this template to show how it can be easily achieved within a Razor Pages Application. Since prerendered content is only updated at deployment, it's primarily only useful for static content like this Blog which is powered by the static markdown content in [_blog/posts](https://github.com/NetCoreTemplates/vue-mjs/tree/main/MyApp/wwwroot/_blog/posts) whose content is prerendered to  `/wwwroot/blog`.

For those interested in utilizing this optimization we've published details on how this works in the [Prerendering Razor Pages
](https://vue-mjs.web-templates.io/blog/prerendering) blog post.

## Develop using JetBrains Rider

<a href="https://www.jetbrains.com/rider/">
<img src="https://raw.githubusercontent.com/ServiceStack/docs/master/docs/images/svg/rider.svg" class="sm:float-left mr-8 w-24 h-24" style="margin-top:0"></a>

Given it's best-of-class support for Web Development we recommend using JetBrains Rider for any kind of JS or TypeScript development. If you're 
using Rider checkout the [Develop using JetBrains Rider](https://vue-mjs.web-templates.io/blog/rider) blog post for an optimal setup for 
Vue.js and Tailwind Web Apps.

## Develop using Visual Studio

<a href="https://visualstudio.microsoft.com/" title="VS Code" class="sm:float-left mr-8">
    <svg class="w-24 h-24" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 254"><defs><linearGradient id="logosVisualStudioCode0" x1="50%" x2="50%" y1="0%" y2="100%"><stop offset="0%" stop-color="#FFF"></stop><stop offset="100%" stop-color="#FFF" stop-opacity="0"></stop></linearGradient><path id="logosVisualStudioCode1" d="M180.828 252.605a15.872 15.872 0 0 0 12.65-.486l52.501-25.262a15.94 15.94 0 0 0 9.025-14.364V41.197a15.939 15.939 0 0 0-9.025-14.363l-52.5-25.263a15.877 15.877 0 0 0-18.115 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.507 91.695a15.853 15.853 0 0 0 5.464 3.571Zm10.464-183.649l-76.262 57.889l76.262 57.888V68.956Z"></path></defs><mask id="logosVisualStudioCode2" fill="#fff"><use href="#logosVisualStudioCode1"></use></mask><path fill="#0065A9" d="M246.135 26.873L193.593 1.575a15.885 15.885 0 0 0-18.123 3.08L3.466 161.482c-4.626 4.219-4.62 11.502.012 15.714l14.05 12.772a10.625 10.625 0 0 0 13.569.604L238.229 33.436c6.949-5.271 16.93-.315 16.93 8.407v-.61a15.938 15.938 0 0 0-9.024-14.36Z" mask="url(#logosVisualStudioCode2)"></path><path fill="#007ACC" d="m246.135 226.816l-52.542 25.298a15.887 15.887 0 0 1-18.123-3.08L3.466 92.207c-4.626-4.218-4.62-11.502.012-15.713l14.05-12.773a10.625 10.625 0 0 1 13.569-.603l207.132 157.135c6.949 5.271 16.93.315 16.93-8.408v.611a15.939 15.939 0 0 1-9.024 14.36Z" mask="url(#logosVisualStudioCode2)"></path><path fill="#1F9CF0" d="M193.428 252.134a15.892 15.892 0 0 1-18.125-3.083c5.881 5.88 15.938 1.715 15.938-6.603V11.273c0-8.318-10.057-12.483-15.938-6.602a15.892 15.892 0 0 1 18.125-3.084l52.533 25.263a15.937 15.937 0 0 1 9.03 14.363V212.51c0 6.125-3.51 11.709-9.03 14.363l-52.533 25.262Z" mask="url(#logosVisualStudioCode2)"></path><path fill="url(#logosVisualStudioCode0)" fill-opacity=".25" d="M180.828 252.605a15.874 15.874 0 0 0 12.65-.486l52.5-25.263a15.938 15.938 0 0 0 9.026-14.363V41.197a15.939 15.939 0 0 0-9.025-14.363L193.477 1.57a15.877 15.877 0 0 0-18.114 3.084L74.857 96.35l-43.78-33.232a10.614 10.614 0 0 0-13.56.603L3.476 76.494c-4.63 4.211-4.635 11.495-.012 15.713l37.967 34.638l-37.967 34.637c-4.623 4.219-4.618 11.502.012 15.714l14.041 12.772a10.614 10.614 0 0 0 13.56.604l43.78-33.233l100.506 91.695a15.857 15.857 0 0 0 5.465 3.571Zm10.464-183.65l-76.262 57.89l76.262 57.888V68.956Z" mask="url(#logosVisualStudioCode2)"></path></svg>
</a>

If you prefer using VS.NET we recommend using VS Code for all your Apps JS front-end development and optionally VS.NET for the back-end C#/.NET development of large .NET Projects. If using Visual Studio checkout the [Develop using Visual Studio](https://vue-mjs.web-templates.io/blog/vs)
blog post for an optimal setup for utilizing Vue.js composition API and Tailwind.

<div class="clear-both"></div>


## Feedback Welcome!

We hope you enjoy these exciting new templates in this release, as always if you have any questions or feedback in this release please let us know in 
[ServiceStack/Discuss](https://github.com/ServiceStack/Discuss/discussions) GitHub Discussions or the [Customer Forums](https://forums.servicestack.net/).


## MSVR 76883

We've received a vulnerability report from the Microsoft Vulnerability Research team last week who found a potential vulnerability in ServiceStack.Redis (.NET Framework) if an attack is able to write a malicious string into a Redis Server and trick an Application into reading it back into a C# DTO with a nested complex type containing a late-bound `object`, the report reads:

> This attack requires a malicious string to be written to the Redis cache and then read back as an object. The most likely attack pattern here is going to involve some sort of injection attack where an application can be tricked into writing untrusted data to a Redis cache that it will later read back.

Unfortunately it's another example of exploiting the same issue that's plagued .NET Serializers for years where there exists classes in .NET Framework where **setting a public instance property** can cause an App to load and execute code in an external .dll. Existence of such dangerous classes means .NET Serializers need to maintain a [Runtime Type Whitelist](/json-format#late-bound-object-and-interface-runtime-types) of Types that are allowed to dynamically instantiated in `object` properties.

This vulnerability found a nested structure code path which skipped the whitelist checks which has since been resolved in this release. 

As a result existing code deserializing non-whitelisted unverified types in late-bound `object` properties will start throwing `NotSupportedException`, to resolve, Types needs to be allowed in the [Runtime Type Whitelist](/json-format#runtime-type-whitelist) which by default can be annotated with:

```csharp
[Serializable]
[DataContract]
[DataContract]
```

Or implement one of these interfaces:

```csharp
ISerializable
IConvertible
IRuntimeSerializable
IReturn<T>
IReturnVoid
IMeta
IVerb                 // IGet, IPost, IPut, IPatch, etc  
ICrud                 // ICreateDb`1, IUpdateDb`1, etc
IAuthTokens
```
